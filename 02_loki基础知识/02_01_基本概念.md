
Grafana Loki是一组组件，可以组成一个功能齐全的日志聚合系统。

Loki与其他日志系统不同是，它只会索引日志的元数据即`labels`(类似Prometheus的labels)，日志数据本身会被压缩并分块(chunck)存储在对象存储中，也可以存储在本地文件系统中。小的索引和高度压缩的分块简化了操作，大大降低了Loki的成本。

项目做正规了，日志系统是少不了的，目前大部分日志平台推荐基于 ELK 构建，不过 ELK 算是比较重了，架构太大，中小项目不太好 Hold 住，希望找一款简单一些的，如果实在找不到再上 ELK，这个时候一款名叫 Loki 的日志系统横空出世。

Loki 是 Grafana Labs 团队最新的开源项目，是一个水平可扩展，高可用性，多租户的日志聚合系统。它的设计非常经济高效且易于操作，因为它不会为日志内容编制索引，而是为每个日志流编制一组标签。项目受 Prometheus 启发，官方的介绍就是：Like Prometheus, but for logs，类似于 Prometheus 的日志系统。



# 1 基本概念

- Loki是一个为有效保存日志数据而优化的数据存储。日志数据的高效索引使Loki区别于其他日志系统。与其他日志系统不同的是，Loki的索引是由标签labels建立的，没有对原始日志信息进行索引。
- Agent负责获取日志，将日志变成数据流，并通过HTTP API将数据流推送给Loki。`Promtail` Agent是为Loki而设计的，但许多其他Agent也能与Loki无缝集成。
- Loki对流进行索引。每个流标识了一组与一组独特标签相关的日志。一组高质量的标签是创建索引的关键，它既紧凑又允许有效的查询执行。
- LogQL是Loki的查询语言。

# 2 Loki的优点

ELK stack和Graylog，ELK目前很多公司都在使用，是一种很不错的分布式日志解决方案，但是需要的组件多，部署和维护相对复杂，并且占用服务器资源多。底层存储是es导致占用服务器资源过多


- **高效地利用内存为日志建立索引**: 通过在一组标签上建立索引，索引可以比其他日志聚合产品小得多。更少的内存使其运行成本更低。
- **多租户**: 允许多个租户使用一个Loki实例。不同租户的数据与其他租户是完全隔离的。多租户是通过在代理中分配一个租户ID来配置的。
- **LogQL，Loki的查询语言**: Prometheus的查询语言PromQL的用户会发现LogQL在生成针对日志的查询方面非常熟悉和灵活。该语言还有助于从日志数据中生成指标，这是一个强大的功能，远远超出了日志聚集的范围。
- **可扩展性**: Loki可以作为一个单一的二进制文件运行；所有的组件都在一个进程中运行。Loki是为可扩展性设计的，因为Loki的每个组件都可以作为微服务运行。配置允许单独扩展微服务。
- **灵活性**: 许多Agent都有插件支持。这使得当前的可观察性技术栈可以添加Loki作为他们的日志聚合工具，而不需要切换观察技术栈的现有部分。
- **Grafana集成**: Loki与Grafana无缝集成，提供了一个完整的可观察性栈。

● 不对日志进行全文本索引。通过存储压缩的，非结构化的日志以及仅索引元数据，Loki 更加易于操作且运行成本更低。  
● 使用与 Prometheus 相同的标签对日志流进行索引和分组，从而使您能够使用与 Prometheus 相同的标签在指标和日志之间无缝切换。  
● 特别适合存储 Kubernetes Pod 日志。诸如 Pod 标签之类的元数据会自动被抓取并建立索引。  
● 在 Grafana 中具有本机支持（需要 Grafana v6.0）。


> - 不对日志进行全文索引。通过存储压缩非结构化日志和仅索引元数据，Loki 操作起来会更简单，更省成本。
> - 通过使用与 Prometheus 相同的标签记录流对日志进行索引和分组，这使得日志的扩展和操作效率更高。
> - 特别适合储存 Kubernetes Pod 日志; 诸如 Pod 标签之类的元数据会被自动删除和编入索引。
> - 受 Grafana 原生支持。

不对日志进行全文索引（vs ELK技）
通过存储压缩非结构化日志和仅索引元数据，Loki 操作起来会更简单，更省成本
通过使用与 Prometheus 相同的标签记录流对日志进行索引和分组，使得日志的扩展和操作效率更高
特别适合储存 Kubernetes Pod 日志; 诸如 Pod 标签之类的元数据会被自动删除和编入索引
适合中小团队对日志平台的需求
受 Grafana 原生支持

## 2.1 便宜的索引方案

loki takes a unique approach by only indexing the metadata rather than the full text of the log lines

在当今日志系统建索引比较稀疏平常的时代，Loki却选择只对Meta类的信息进行索引，这样索引的存储量可以做到非常小，相比于原文。可以忽略不计。在查询的时候，先做Meta数据过滤，再做数据Scan（硬扫），然后计算出结果。

  

![](https://pic1.zhimg.com/80/v2-63cbedb2bff517e6a475fe2789a85fc4_720w.webp)

那么，哪些数据算是Loki说的Meta数据呢？常见的有这几类

- 日志的时间字段
- 主机名/IP地址
- k8s中的pod信息
- 业务定义的一些类型，往往可以枚举

这些Meta数据可以在采集的时候指定。



## 2.2 拥抱云时代的存储

Loki在设计产品的时候，充分利用到了云时代的存储。当下Object Storage越来越成为标准化的存储服务，海外的AWS S3、国内 阿里云OSS等都提供了领先的对象存储服务。 作为新生代的日志存储软件，也完全拥抱了云上的存储方案。

据笔者测试，通过简单配置，Loki可以将日志以Gzip压缩的方式存储在对象存储上。 价格低廉


## 2.3 Promtheus 风格的采集和查询

Grafana 在官网表明，Loki受到了Prometheus的启发。 我们也在两个部分看到了Loki的Prometheus的风格。

    采集的组件叫Promtail，配置和Prometheus非常相似
    查询的时候，Loki的LogQL和PromQL 如出一辙，比如类似label过滤，指标的agg计算


# 3 背景和动机


当我们的容器云运行的应用或者某个节点出现问题了，解决思路应该如下：

[![](https://raw.githubusercontent.com/wsgzao/storage-public/master/img/20201030154333.png)](https://raw.githubusercontent.com/wsgzao/storage-public/master/img/20201030154333.png)

我们的监控使用的是基于 Prometheus 体系进行改造的，Prometheus 中比较重要的是 Metric 和 Alert，Metric 是来说明当前或者历史达到了某个值，Alert 设置 Metric 达到某个特定的基数触发了告警，但是这些信息明显是不够的。

我们都知道，Kubernetes 的基本单位是 Pod，Pod 把日志输出到 Stdout 和 Stderr，平时有什么问题我们通常在界面或者通过命令查看相关的日志。

举个例子：当我们的某个 Pod 的内存变得很大，触发了我们的 Alert。这时管理员，去页面查询确认是哪个 Pod 有问题，然后要确认 Pod 内存变大的原因，我们还需要去查询 Pod 的日志，如果没有日志系统，那么我们就需要到页面或者使用命令进行查询：


[![](https://raw.githubusercontent.com/wsgzao/storage-public/master/img/20201030162229.png)](https://raw.githubusercontent.com/wsgzao/storage-public/master/img/20201030162229.png)

如果，这个时候应用突然挂了，这个时候我们就无法查到相关的日志了。所以需要引入日志系统，统一收集日志。而使用 ELK 的话，就需要在 Kibana 和 Grafana 之间切换，影响用户体验。所以 ，Loki 的第一目的就是最小化度量和日志的切换成本，有助于减少异常事件的响应时间和提高用户的体验。



# 4 ELK 存在的问题

现有的很多日志采集的方案都是采用全文检索对日志进行索引（如 ELK 方案），优点是功能丰富，允许复杂的操作。但是，这些方案往往规模复杂，资源占用高，操作苦难。很多功能往往用不上，大多数查询只关注一定时间范围和一些简单的参数（如：host、service 等），使用这些解决方案就有点杀鸡用牛刀的感觉了。

[![](https://raw.githubusercontent.com/wsgzao/storage-public/master/img/20201030162252.png)](https://raw.githubusercontent.com/wsgzao/storage-public/master/img/20201030162252.png)

因此，Loki 的第二个目的是，在查询语言的易操作性和复杂性之间可以达到一个权衡。


# 5 Loki vs ELK

Loki 和 ELK（Elasticsearch, Logstash, Kibana）都是常用的日志处理系统，它们各自具有一些优点。下面是 Loki 相对于 ELK 的几个优点：

- 存储效率更高：Loki 使用了压缩和切割日志数据的方法来减少存储空间的占用，相比之下，ELK 需要维护一个大的索引，需要更多的存储空间。
- 查询速度更快：Loki 使用类似 Prometheus 的标签索引机制存储和查询日志数据，这使得它能够快速地进行分布式查询和聚合，而不需要将所有数据都从存储中加载到内存中。而ELK需要将数据从存储中加载到内存中进行查询，查询速度相对较慢。
- 部署和管理更容易：Loki 是一个轻量级的日志聚合系统，相比之下，ELK 需要部署和管理多个组件，需要更多的资源和人力成本。

# 6 成本考量

全文检索的方案也带来成本问题，简单的说就是全文搜索（如：ES）的倒排索引的切分和共享的成本较高。后来出现了其他不同的设计方案，如：

- OKlog

项目地址：[https://github.com/oklog/oklog](https://github.com/oklog/oklog)

采用最终一致的、基于网格的分布策略。这两个设计决策提供了大量的成本降低和非常简单的操作，但是查询不够方便。因此，Loki 的第三个目的是，提供一个更具成本效益的解决方案。





